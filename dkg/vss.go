package dkg

// Verifiable Secret Sharing (VSS) implementation for Distributed Key Generation
//
// This package implements VSS primitives that allow participants to verify
// that shares they received are consistent with commitments published by the
// dealer, ensuring all participants can reconstruct the same secret.
//
// Ported from liboprf's dkg-vss.c

import (
	"crypto/rand"
	"crypto/subtle"
	"errors"
	"io"
	"sort"

	"github.com/gtank/ristretto255"
	"github.com/wurp/go-oprf/toprf"
)

const (
	// ScalarBytes is the size of a ristretto255 scalar
	ScalarBytes = 32
	// ElementBytes is the size of a ristretto255 element
	ElementBytes = 32
)

// H is the "nothing up my sleeve" generator for VSS Pedersen commitments.
// Generated by hashing "DKG Generator H on ristretto255" to the curve.
// From dkg-vss.c line 10-14
var H = mustDecodeElement([]byte{
	0x66, 0x4e, 0x4c, 0xb5, 0x89, 0x0e, 0xb3, 0xe4,
	0xc0, 0xd5, 0x48, 0x02, 0x74, 0x8a, 0xb2, 0x25,
	0xf9, 0x73, 0xda, 0xe5, 0xc0, 0xef, 0xc1, 0x68,
	0xf4, 0x4d, 0x1b, 0x60, 0x28, 0x97, 0x8f, 0x07,
})

// mustDecodeElement decodes bytes into a ristretto255 element, panicking on error.
// Used only for decoding hardcoded constants during initialization.
func mustDecodeElement(b []byte) *ristretto255.Element {
	e := ristretto255.NewElement()
	if err := e.Decode(b); err != nil {
		panic("failed to decode hardcoded element: " + err.Error())
	}
	return e
}

// Commit creates a Pedersen commitment to value a with blinding factor r.
// Returns C = g^a Â· h^r where g is the ristretto255 base point and h is H.
//
// Corresponds to dkg_vss_commit() in dkg-vss.c:16-30
func Commit(a, r *ristretto255.Scalar) (*ristretto255.Element, error) {
	// X = g^a
	X := ristretto255.NewElement().ScalarBaseMult(a)

	// R = H^r
	R := ristretto255.NewElement().ScalarMult(r, H)

	// C = X + R
	C := ristretto255.NewElement().Add(X, R)

	return C, nil
}

// Share creates shares of a secret with Pedersen commitments.
//
// Parameters:
//   - n: number of participants
//   - threshold: minimum shares needed to reconstruct (must be > 0)
//   - secret: the secret to share (if nil, a random secret is generated)
//
// Returns:
//   - commitments: array of n commitments, one per share
//   - shares: array of n share pairs [secret_share, blinding_share]
//   - blind: the blinding factor b[0] used in commitments
//
// Corresponds to dkg_vss_share() in dkg-vss.c:32-68
func Share(n, threshold uint8, secret *ristretto255.Scalar) (
	commitments []*ristretto255.Element,
	shares [][2]toprf.Share,
	blind *ristretto255.Scalar,
	err error,
) {
	if threshold == 0 {
		return nil, nil, nil, errors.New("threshold must be > 0")
	}

	// Generate random polynomial coefficients for secret and blinding
	a := make([]*ristretto255.Scalar, threshold)
	b := make([]*ristretto255.Scalar, threshold)

	// a[0] is the secret (or random if secret is nil)
	if secret != nil {
		a[0] = ristretto255.NewScalar()
		a[0].Decode(secret.Encode(nil))
	} else {
		var err error
		a[0], err = randomScalar()
		if err != nil {
			return nil, nil, nil, err
		}
	}

	// Generate remaining coefficients for both polynomials
	for k := uint8(1); k < threshold; k++ {
		var err error
		a[k], err = randomScalar()
		if err != nil {
			return nil, nil, nil, err
		}
	}
	for k := uint8(0); k < threshold; k++ {
		var err error
		b[k], err = randomScalar()
		if err != nil {
			return nil, nil, nil, err
		}
	}

	// Blinding factor is b[0]
	blind = ristretto255.NewScalar()
	blind.Decode(b[0].Encode(nil))

	// Create shares and commitments for each participant
	commitments = make([]*ristretto255.Element, n)
	shares = make([][2]toprf.Share, n)

	for j := uint8(1); j <= n; j++ {
		// f(j) = a[0] + a[1]*j + a[2]*j^2 + ... + a[threshold-1]*j^(threshold-1)
		shares[j-1][0] = polynom(j, threshold, a)

		// f'(j) = b[0] + b[1]*j + b[2]*j^2 + ... + b[threshold-1]*j^(threshold-1)
		shares[j-1][1] = polynom(j, threshold, b)

		// Commitment to this share
		c, err := Commit(shares[j-1][0].Value, shares[j-1][1].Value)
		if err != nil {
			return nil, nil, nil, err
		}
		commitments[j-1] = c
	}

	return commitments, shares, blind, nil
}

// VerifyShareCommitment checks that a VSS share pair matches its Pedersen commitment.
//
// Corresponds to dkg_vss_verify_commitment() in dkg-vss.c:70-76
func VerifyShareCommitment(commitment *ristretto255.Element, share [2]toprf.Share) error {
	// Recompute commitment from share
	c, err := Commit(share[0].Value, share[1].Value)
	if err != nil {
		return err
	}

	// Compare commitments
	cBytes := c.Encode(nil)
	commitmentBytes := commitment.Encode(nil)
	if subtle.ConstantTimeCompare(cBytes, commitmentBytes) != 1 {
		return errors.New("commitment verification failed")
	}

	return nil
}

// CombineShares combines shares from qualified participants to compute the final
// secret share and its commitment (VSS version with Pedersen commitments).
//
// Parameters:
//   - qual: indices of qualified participants (0-terminated)
//   - shares: all shares received from participants
//   - self: index of current participant
//
// Returns:
//   - finalShare: combined share pair [secret, blinding]
//   - commitment: commitment to the final share
//
// Corresponds to dkg_vss_finish() in dkg-vss.c:78-100
func CombineShares(qual []uint8, shares [][2]toprf.Share, self uint8) (
	finalShare [2]toprf.Share,
	commitment *ristretto255.Element,
	err error,
) {
	// Initialize final share to zero
	share0 := ristretto255.NewScalar()
	share1 := ristretto255.NewScalar()

	// Sum shares from qualified participants
	for _, qualIndex := range qual {
		if qualIndex == 0 {
			break // 0-terminated list
		}
		if qualIndex < 1 || int(qualIndex) > len(shares) {
			return finalShare, nil, errors.New("invalid qualified index")
		}

		idx := qualIndex - 1
		// Check that share has correct index
		if shares[idx][0].Index != self {
			return finalShare, nil, errors.New("share has incorrect index")
		}

		// Add to running sum
		share0.Add(share0, shares[idx][0].Value)
		share1.Add(share1, shares[idx][1].Value)
	}

	// Store final shares
	finalShare[0].Index = self
	finalShare[0].Value = share0
	finalShare[1].Index = self
	finalShare[1].Value = share1

	// Compute commitment
	commitment, err = Commit(share0, share1)
	if err != nil {
		return finalShare, nil, err
	}

	return finalShare, commitment, nil
}

// ReconstructSecret recovers the secret from a set of VSS share pairs.
//
// Parameters:
//   - t: threshold (minimum shares needed)
//   - x: point to evaluate at (typically 0 for the secret)
//   - shares: array of share pairs [secret, blinding]
//   - commitments: optional commitments to verify shares (nil to skip verification)
//
// Returns:
//   - result: the reconstructed value at x
//   - blind: the reconstructed blinding value (if commitments were verified)
//
// Corresponds to dkg_vss_reconstruct() in dkg-vss.c:117-150
func ReconstructSecret(t uint8, x uint8, shares [][2]toprf.Share, commitments []*ristretto255.Element) (
	result, blind *ristretto255.Scalar,
	err error,
) {
	if len(shares) > 128 {
		return nil, nil, errors.New("too many shares")
	}

	// Collect valid shares
	type validShare struct {
		share [2]toprf.Share
		index int
	}
	var valid []validShare

	for i, share := range shares {
		// Verify commitment if provided
		if commitments != nil && i < len(commitments) {
			if err := VerifyShareCommitment(commitments[i], share); err != nil {
				continue // Skip invalid shares
			}
		}
		valid = append(valid, validShare{share: share, index: i})
		if len(valid) >= int(t) {
			break
		}
	}

	if len(valid) < int(t) {
		return nil, nil, errors.New("insufficient valid shares")
	}

	// Sort by share index
	sort.Slice(valid, func(i, j int) bool {
		return valid[i].share[0].Index < valid[j].share[0].Index
	})

	// Extract first t shares for interpolation
	secretShares := make([]toprf.Share, t)
	blindingShares := make([]toprf.Share, t)
	for i := uint8(0); i < t; i++ {
		secretShares[i] = valid[i].share[0]
		blindingShares[i] = valid[i].share[1]
	}

	// Interpolate to recover value at x
	result, err = toprf.InterpolateScalar(x, secretShares)
	if err != nil {
		return nil, nil, err
	}

	// Also interpolate blinding if needed
	if commitments != nil {
		blind, err = toprf.InterpolateScalar(x, blindingShares)
		if err != nil {
			return nil, nil, err
		}
	}

	return result, blind, nil
}

// randomScalar generates a cryptographically secure random scalar.
func randomScalar() (*ristretto255.Scalar, error) {
	var buf [64]byte
	if _, err := io.ReadFull(rand.Reader, buf[:]); err != nil {
		return nil, err
	}
	return ristretto255.NewScalar().FromUniformBytes(buf[:]), nil
}

// polynom evaluates a polynomial at point j.
// f(j) = a[0] + a[1]*j + a[2]*j^2 + ... + a[threshold-1]*j^(threshold-1)
//
// This is a helper function used by Share().
// Corresponds to polynom() in dkg.c:45-68
func polynom(j uint8, threshold uint8, a []*ristretto255.Scalar) toprf.Share {
	// Start with a[0]
	value := ristretto255.NewScalar()
	value.Decode(a[0].Encode(nil))

	// z = j (as scalar)
	z := ristretto255.NewScalar()
	zBytes := [32]byte{j}
	z.Decode(zBytes[:])

	// Add terms a[t] * z^t for t=1..threshold-1
	for t := uint8(1); t < threshold; t++ {
		// Compute z^t
		tmp := ristretto255.NewScalar()
		tmp.Decode([]byte{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}) // = 1

		for exp := uint8(1); exp <= t; exp++ {
			tmp.Multiply(tmp, z)
		}

		// tmp = a[t] * z^t
		tmp.Multiply(a[t], tmp)

		// Add to result
		value.Add(value, tmp)
	}

	return toprf.Share{
		Index: j,
		Value: value,
	}
}
